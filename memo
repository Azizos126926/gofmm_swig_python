This is a memo to document what I did for my master thesis on a daily
basis. It not only includes the stuff that I successfully implemented,
but also the problems that I encountered. Moreover, it will also contain
the discussion with my advisor and though process.

I hope this file could guide me to a clear goal of our project.


15.12.2020
Modified set_env.sh, CMakeLists.txt and wrote a new swig.sh to add a
linker file with liblapack, libblas libraries in the run time.

Figured out seg fault problem in call_Launchhelper(). We must initialize
a separate memeory block in runtime


16.12.2020

Reading day!

Read format in .i file about swig: %include, %inline, global var...,
static linking, extern


17.12.2020

Designed basic working case: first start with the implementation of
running dense matrix

wrote functions: SPDMATRIX_DENSE, launchhelper_denseSPD

problem encountered: see the issue in gitlab with the title 

        Cant read the binary matrix file from .sh


18.12.2020

Solved the issue from 17.12.2020 (see solution in gitlab)

modified tools.i file so that SPDMATRIX_DENSE function is callable in python


20.12.2020
1. rewrote launchhelper_denseSPD so that it could take as an parameter
a file path to the parameters file. It runs succesfully

2. Modified the constructor of gofmm::CommandLineHelper so that it can
take a vector as a parameter. This proves much cleaner and understandble
since we can avoid realloc (and general memory management) which typically happens when
we want to read file into char**

3. wrote file_to_argv: which reads a file into vector. Due to memory
issue related to local vars, this function is still under construction.

4. wrote `compile_log.txt`: document what the output of key cmds in the
compilitaion should look like. Users who intend to install gofmm + hmlp package
should consult it.


21.12.2020
1. Finished part 3 of the date 20.12.2020. Namely, wrote file_to_argv
class to wrap parameters from a txt file  into a class object.

  a. This class reduces hard coding, eg, when we need to run two different spd
     matrix, testsuit + spd dense, we don't need hard coding
  b. Use destructor to smartly clean up the memory space occupied by the vector

It runs successfully

2. Wrote test_gofmm.h file so that functions in test_gofmm.cpp could
reference each other without worrying about order


22.12.2020
1. Add all current functions in .cpp to its .h file so that
  a. The interface is cleaner
  b. No restriction of function call order in .cpp


05.01.2021
1. Reading day:)
2. Create infrastructure for storing matrix in a tree (see typedef in .h)
3. Finished the function compress
4. Finished the function evaluate


08.01.2021
1. Changed `cmds`

TASK: implement a function as folllows which takes `AA` as an input numpy
matrix declared in the python console

tools.launchhelper_denseSPD(AA, "parameters_dense.txt")


19.01.2021

1. Read where the matrix val was stored by looking at the `vector` and
`Data` class

2. Updated the `tools.i` file to implement the `numpy` usage

3. Wrote the function `load_denseSPD_from_console` to take a `numpy` array
as input and produces a tree-contained spd matrix as output.

Here are the stuff that I consulted for implementation

How to deal with numpy in c++
https://numpy.org/doc/stable/reference/swig.html

Case with 1D numpy array to work with:
https://stackoverflow.com/questions/52199057/c-array-to-numpy-with-swig-problem-with-typeerror

https://numpy.org/doc/stable/reference/swig.interface-file.html

// since the class inherits from vector (public vector<T, Allocator>),
// it has the method data(). Documentation is as follows:
// http://www.cplusplus.com/reference/vector/vector/data/
file.seekg( 0, std::ios::beg );
if ( !file.read( (char*)this->data(), size ) )
{
std::cerr << "ERROR: only " << file.gcount() << " bytes, expecting " << m * n * sizeof(T) << std::endl;
}
file.close();


20.01.2021

1. Further updated `tools.i` so that a `numpy` array could be imported
succesfully in `swig`

2. Wrote `test.py` to demonstrate how the task to implement `numpy` and
`gofmm` together works

3. For user-input lower dimensional `numpy` array, we must fine-tuning the
# of children of the tree.

In the end, the `test.py` runs succesfully for numpy array of size > 10
(both gofmm and accuracy report work) but for size < 10 only gofmm works.

[getianyi@Ubuntu build]$ python3 test.py
testsuit
partitioning ...
[ RT]     1 [normal]     0 [nested] 0.000E+00 flops 0.000E+00 mops
[ RT]     1 [normal]     0 [nested] 0.000E+00 flops 0.000E+00 mops
omp_get_max_threads() 4
Dependency clean up
[ RT]     1 [normal]     0 [nested] 0.000E+00 flops 0.000E+00 mops
Finish NearSamplesTask
Finish SymmetrizeNearInteractions
Skeletonization (HMLP Runtime) ...
[ RT]     4 [normal]     0 [nested] 0.000E+00 flops 0.000E+00 mops
MergeFarNodes ...
CacheFarNodes ...
========================================================
GOFMM compression phase
========================================================
NeighborSearch ------------------------  0.00s (  0.0%)
partitioning ----------------------  0.01s ( 88.2%)
Skeletonization -----------------------  0.00s ( 11.3%)
MergeFarNodes -------------------------  0.00s (  0.1%)
CacheFarNodes -------------------------  0.00s (  0.4%)
========================================================
Compress (1.00 not compressed) --------  0.02s (100.0%)
========================================================

Forward permute ...
N2S, S2S, S2N, L2L (HMLP Runtime) ...
[ RT]     7 [normal]     0 [nested] 9.216E+03 flops 9.243E+03 mops
d2h_t 0.000000s
aggregate_t 0.000000s
Backward permute ...
========================================================
GOFMM evaluation phase
========================================================
Allocate ------------------------------  0.00s (  3.8%)
Forward permute -----------------------  0.00s ( 14.9%)
N2S, S2S, S2N, L2L --------------------  0.00s ( 65.8%)
Backward permute ----------------------  0.00s ( 15.4%)
========================================================
Evaluate ------------------------------  0.00s (100.0%)
========================================================

========================================================
Accuracy report
========================================================
gid      0, ASKIT 0.0E+00, HODLR 0.0E+00, GOFMM 0.0E+00
gid      1, ASKIT 0.0E+00, HODLR 0.0E+00, GOFMM 0.0E+00
gid      2, ASKIT 0.0E+00, HODLR 0.0E+00, GOFMM 0.0E+00
========================================================
Elementwise ASKIT 0.0E+00, HODLR 0.0E+00, GOFMM 0.0E+00
========================================================
[ RT]     1 [normal]     0 [nested] 0.000E+00 flops 0.000E+00 mops
python3: ../gofmm/igofmm.hpp:652: void hmlp::gofmm::Factor<T>::Telescope(bool, hmlp::Data<T>&, hmlp::Data<T>&) [with T = float]: Assertion `Palr.col() == n' failed.
Aborted (core dumped)


Task: find a way to fine tuning the children #


22.01.2021

1. Find how to fine tuning the parameters `m` and `s` in accordance with
`n`


## problem size
n=5000
## maximum leaf node size
m=64
## maximum off-diagonal ranks
s=64
## number of neighbors
k=0
## number of right hand sides
nrhs=512
## user tolerance
stol=1E-5
## user computation budget [0,1]
budget=0.00
## distance type (geometry, kernel, angle)
distance="angle"
## spdmatrix type (testsuit, dense, ooc, kernel, userdefine)
matrixtype="testsuit"
## kernelmatrix type (gaussian, laplace)
kerneltype="gaussian"


25.01.2021

1. Combined all 3 cases: testsuit, dense spd and numpy into the file 
`test.py`

Task to do:

1.   auto u = Evaluate( tree, w );  // type: Data<T>

extract data from the container and do multiplication

question: multiplication 

should 
       Data<T> mul(Data<T> ..., Data<T> ...) {}



29.01.2021
https://stackoverflow.com/questions/36222455/swigcpython-passing-and-receiving-c-arrays

# 2D spd matrix
# spdMatrix = np.array([[2, 6], [6, 20]], dtype=np.double)

2D ARGOUT_ARRAY2 map not avilable
test.py mul case updated
mul_denseSPD written
